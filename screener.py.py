# -*- coding: utf-8 -*-
"""ALL IN ONE MONTHLY

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15sBOgiay-pbgzs8zGNWw_PdqM6Pl9tKD
"""

# ===========================================
# NSE Stock Screener with RS, ADX, RSI, VSTOP, Donchian High
# Daily, Weekly, or Monthly timeframes
# Shows full list + filtered "HOLD/SELL â†’ BUY" list
# Now exports both CSV and PDF, and removes ".NS" from output
# ===========================================

!pip install yfinance ta pandas numpy reportlab --quiet

import yfinance as yf
import pandas as pd
import numpy as np
import ta
from time import sleep
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle
from reportlab.lib import colors
from reportlab.lib.pagesizes import A4

# ===== SETTINGS =====
timeframe = "1mo"  # "1d" for daily, "1wk" for weekly, "1mo" for monthly
rs_ma_length = 10
adx_len = 14
adx_thresh = 25
vstop_length = 10
vstop_factor = 2.5
donchian_len = 12
benchmark = "^NSEI"

# ===== RS lookback based on timeframe =====
if timeframe == "1d":
    rs_period = 252   # 1 year trading days
    period_download = "2y"
elif timeframe == "1wk":
    rs_period = 52
    period_download = "3y"
elif timeframe == "1mo":
    rs_period = 12
    period_download = "15y"  # monthly needs long history for RS
else:
    raise ValueError("Invalid timeframe. Use '1d', '1wk', or '1mo'.")

# ===== Get all NSE symbols =====
url = "https://archives.nseindia.com/content/equities/EQUITY_L.csv"
nse_df = pd.read_csv(url)
nse_tickers = [sym + ".NS" for sym in nse_df["SYMBOL"].unique()]
print(f"Total NSE stocks: {len(nse_tickers)}")

# ===== PDF Export Function =====
def export_pdf(filename, df):
    doc = SimpleDocTemplate(filename, pagesize=A4)
    data = [df.columns.tolist()] + df.values.tolist()
    table = Table(data)
    table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.gray),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 6),
        ('GRID', (0, 0), (-1, -1), 1, colors.black)
    ]))
    doc.build([table])

# ===== Signal computation =====
def compute_signals_for_chunk(chunk):
    data = yf.download(chunk + [benchmark], period=period_download, interval=timeframe,
                       group_by="ticker", auto_adjust=False, threads=True)
    results = []
    for sym in chunk:
        try:
            df = data[sym].dropna()
            bench_df = data[benchmark].loc[df.index]

            if len(df) < rs_period + 2:
                continue

            # === RS ===
            res = (df['Close'] / df['Close'].shift(rs_period)) / \
                  (bench_df['Close'] / bench_df['Close'].shift(rs_period)) - 1
            rsPositive = res > 0

            # === RP ===
            rp = df['Close'].pct_change() > bench_df['Close'].pct_change()

            # === ADX ===
            adx = ta.trend.adx(high=df['High'], low=df['Low'], close=df['Close'], window=adx_len)
            adxSignal = adx >= adx_thresh

            # === RSI ===
            rsi = ta.momentum.rsi(df['Close'], window=14)
            rsiSignal = rsi >= 45

            # === VSTOP ===
            atr = ta.volatility.average_true_range(df['High'], df['Low'], df['Close'], window=vstop_length)
            stop = pd.Series(index=df.index, dtype=float)
            max_, min_ = np.nan, np.nan
            uptrend = True
            for i in range(len(df)):
                src = df['Close'].iloc[i]
                atrM = atr.iloc[i] * vstop_factor
                max_ = src if np.isnan(max_) else max(max_, src)
                min_ = src if np.isnan(min_) else min(min_, src)
                stop.iloc[i] = src if i == 0 or np.isnan(stop.iloc[i-1]) else \
                    max(stop.iloc[i-1], max_ - atrM) if uptrend else min(stop.iloc[i-1], min_ + atrM)
                uptrend = src > stop.iloc[i]
            vstopSignal = df['Close'] > stop

            # === Donchian High ===
            dcHigh = df['High'] == df['High'].rolling(donchian_len).max()

            # === Final Signal ===
            rsCurr, vstopCurr, dcHighCurr = rsPositive.iloc[-1], vstopSignal.iloc[-1], dcHigh.iloc[-1]
            buy = rsCurr and vstopCurr and dcHighCurr
            sell = (not rsCurr) and (not vstopCurr) and (not dcHighCurr)
            signal_now = "BUY" if buy else "SELL" if sell else "HOLD"

            rsPrev, vstopPrev, dcHighPrev = rsPositive.iloc[-2], vstopSignal.iloc[-2], dcHigh.iloc[-2]
            buy_prev = rsPrev and vstopPrev and dcHighPrev
            sell_prev = (not rsPrev) and (not vstopPrev) and (not dcHighPrev)
            signal_prev = "BUY" if buy_prev else "SELL" if sell_prev else "HOLD"

            results.append({
                "Symbol": sym,
                "RP": "ðŸŸ¢" if rp.iloc[-1] else "ðŸ”´",
                "RS": "ðŸŸ¢" if rsCurr else "ðŸ”´",
                "ADX": "ðŸŸ¢" if adxSignal.iloc[-1] else "ðŸ”´",
                "RSI": "ðŸŸ¢" if rsiSignal.iloc[-1] else "ðŸ”´",
                "VSTOP": "ðŸŸ¢" if vstopCurr else "ðŸ”´",
                "DC High": "ðŸŸ¢" if dcHighCurr else "ðŸ”´",
                "Prev Signal": signal_prev,
                "Signal": signal_now
            })
        except Exception as e:
            print(f"Skipping {sym}: {e}")
    return results

# ===== Process all NSE stocks =====
all_results = []
batch_size = 200
for i in range(0, len(nse_tickers), batch_size):
    chunk = nse_tickers[i:i+batch_size]
    results = compute_signals_for_chunk(chunk)
    all_results.extend(results)
    print(f"Processed {i+len(chunk)}/{len(nse_tickers)} stocks")
    sleep(1)

df_final = pd.DataFrame(all_results)

# ===== Remove ".NS" suffix =====
df_final["Symbol"] = df_final["Symbol"].str.replace(".NS", "", regex=False)

# ===== Filter: HOLD/SELL â†’ BUY =====
df_filtered = df_final[
    (df_final["Signal"] == "BUY") &
    (df_final["Prev Signal"].isin(["HOLD", "SELL"]))
]

# ===== Show in Colab =====
print("\n=== FULL SIGNAL LIST ===")
display(df_final)
print("\n=== FILTERED: HOLD/SELL â†’ BUY ===")
display(df_filtered)

# ===== Save CSV =====
df_final.to_csv("nse_full_signals.csv", index=False)
df_filtered.to_csv("nse_hold_sell_to_buy.csv", index=False)

# ===== Save PDF =====
export_pdf("nse_full_signals.pdf", df_final)
export_pdf("nse_hold_sell_to_buy.pdf", df_filtered)

print("\nFiles saved: nse_full_signals.csv, nse_hold_sell_to_buy.csv, nse_full_signals.pdf, nse_hold_sell_to_buy.pdf")